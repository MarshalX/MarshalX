{"componentChunkName":"component---src-templates-post-jsx","path":"/blog/post/python-interpretatory-baytkod-pyc-pyo-pyd-jit-i-prochee","result":{"data":{"prismicPost":{"id":"Prismic__Post__Xm5rZREAACMAB9KX","uid":"python-interpretatory-baytkod-pyc-pyo-pyd-jit-i-prochee","first_publication_date":"2020-03-15T17:52:42+0000","last_publication_date":"2020-03-15T17:53:26+0000","data":{"title":{"text":"Python, интерпретаторы, байткод, .pyc, .pyo, .pyd, JIT и прочее"},"description":"Разберём что такое Python, какие у него есть реализации. Поговорим о подходах к выполнению кода. О машинном коде, байткоде, компиляции и интерпретации. Заострим внимание на CPython'e, глянем на одну из причин медленности - отсутствие JIT. Узнаем что такое pyc файлы, а что pyo.","date":"22.02.2020","categories":[{"category":{"document":[{"id":"Prismic__Category__Xm4I9BEAACMABh0C","uid":"pro-python","data":{"name":"Про Python"}}]}}],"body":[{"__typename":"PrismicPostBodyText","slice_type":"text","id":"Prismic__PostBodyText__Prismic__Post__Xm5rZREAACMAB9KX__body__0","primary":{"text":{"html":"<p>Заголовок сочный, но как и говорил, всё очень кратко.</p><p>Давайте для начала примем, что <em>Python</em> - это <strong>интерфейс</strong>. Просто существует определённый набор того, что и как должно происходить, как должно себя вести.</p><p>Только выбрав имплементацию интерфейса уже можно говорить что-то о компиляции, байткоде и т.д. По дефолту такой реализацией является <em>CPython</em> - он же официальный (от самих разработчиков), он же самый популярный. Его и выберем, а о других просто будем знать, чтобы при необходимости заюзать.</p><p>Есть машинный код, а есть байткод. Машинный код прекрасен тем, что позволяет напрямую выполнять инструкции процессором. Байткод - некий промежуточный язык, понятный только виртуальной машине, которая и выполняет инструкции. Фишка машинного кода в том, что он дико быстрый, а байткода - возможность работать на разных платформах благодаря тому, что виртуальную машину можно написать для разных ОС и запускать один и тот же код везде. Так же байткод является более защищенным по очевидным причинам.</p><p>Дык вот <em>CPython</em> <strong>компилирует</strong> наш код в байткод. А потом выполняет его на своей виртуальной машине.</p><p>Собсна тоже самое и делает <em>Java</em>. У неё есть своя <em>JVM</em>, но почему-то она намного быстрее <em>Python&#39;a</em>. Дело во многих вещах, но пока я затрону одно - <em>JIT</em>. </p><p><em>JIT</em> - компиляция на лету. Фича в том, что у нас есть байткод, но было бы классно ещё и машинный местами использовать, чтобы ускорить выполнение. Этим и занимается <em>Just in Time </em>компиляция. Какие-то жирные куски, если есть возможность, она оптимайзит, компилирует в машинный код. Не всё так радужно, конечно. Ибо компиляция занимает время, но если выполнение и правда ускорится в разы, то это оправдано.</p><p>У <em>JVM JIT </em>есть, у <em>CPython</em> - нет. Обусловлено это тем, что <em>CPython</em> пытается быть всем и для всех. Из-за <em>JIT</em> программы долго запускаются. Если написать скрипт для выполнения в консоле, то нужен ли нам долгий запуск? Но <em>CPython</em> всего-лишь одна реализация интерфейса! И если мы точно знаем, что у нас, например, веб-приложение и мы запускаемся очень редко, а потом всё работаем и работаем - было бы классо иметь <em>JIT</em> и он у нас есть! В другой реализации - <em><strong>PyPy</strong></em>! Для <em>JIT</em> есть еще <em>Numba</em>. Кста, забыл упомянуть, что <em>CPython</em> позволяет прикрутить к себе <em>JIT</em>.</p><p>Сухой список реализаций <em>Python&#39;a</em>:</p><p>- <em>PyPy</em> - написан на <em>RPython</em>, использует <em>JIT</em>, отлично совместим с <em>CPython</em> (а это позволяет запускать <em>Django</em>, <em>Flask</em> и другие проекты без каких-либо изменений).</p><ul><li>Jython - компилирует наш python код в байткод для JVM (Java).</li><li>IronPython - C++.</li><li>Brython - JavaScript.</li><li>RubyPython - Ruby.</li></ul><p>и т.д. и т.п.</p><p>Есть ещё <em>Cython</em>, который трында бустит код в связи с второй траблой плутона - динамической типизацией.</p><p>Вернёмся к <em>CPython</em>. Он правда компилирует. Результатом компиляции являются<strong> .pyc</strong> файлы, который вы можете встречать после запуска своих приложений. Хочу отметить, что данные файлы появляются только у модулей. Когда вы импортируете какой-либо другой файл, только в этом случае его байткод будет сохранён в файл! Когда вы устанавливаете пакеты, через <em>setup.py</em> там, например, то при установке весь пакет компилируется и рядом с оригинальными<em> .py </em>файлами появляются скомпилированные <em>.pyc</em>!</p><p>Нужда в перекомпиляции определяется по множеству критериев, но есть один основной - дата изменения файла. Если<em> .py</em> изменён раньше, чем создан<em> .pyc</em>, то будет использовал скопилированный байткод. Ну тут вылезают рофлы с таймзоной и т.д. Да и вообще, это &quot;компиляция&quot; бустит только скорость запуска.</p><p>С <em>.pyc </em>разобрались, переходим к <strong>.pyo</strong>. Данные файлы - это тоже самое, что и <em>.pyc</em>, только без относительного мусора. Фишка в том, что будут вырезаны инструкции необходимые, например, для дебага. Или убраны все <em>docstrings</em>. Для получения таких файлов необходимо запустить интерпритатор с аргом <em>-O</em> для первого случая и <em>-OO</em> для второго.</p><p><strong>.pyd</strong> - всё ещё проще. Доступно только для шиндовса и знаете что это? <strong>Обычные DLL&#39;ки! </strong>Да, конечно у вас в коде тогда должен быть метод, для точки входа и бла-бла, но по сути просто ддлка с парочкой отличий.</p>"}}}]}},"posts":{"nodes":[{"id":"Prismic__Post__Z3AWEBEAACQAq0KX","uid":"2024","data":{"title":{"text":"Итоги Года 2024"},"date":"28.12.2024","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__ZYgWYhAAACYAKMp2","uid":"2023","data":{"title":{"text":"Итоги Года 2023"},"date":"31.12.2023","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__Y62KDBAAACYAwfBO","uid":"2022","data":{"title":{"text":"Итоги Года 2022"},"date":"31.12.2022","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__Y639RhAAACMAwpTU","uid":"2021","data":{"title":{"text":"Итоги Года 2021"},"date":"31.12.2021","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}}]}},"pageContext":{"uid":"python-interpretatory-baytkod-pyc-pyo-pyd-jit-i-prochee"}}}