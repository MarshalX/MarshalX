{"componentChunkName":"component---src-templates-post-jsx","path":"/blog/post/kak-ustroen-slovar-dict-v-python","result":{"data":{"prismicPost":{"id":"Prismic__Post__Xm56HxEAACAACBR0","uid":"kak-ustroen-slovar-dict-v-python","first_publication_date":"2020-03-15T18:55:29+0000","last_publication_date":"2020-03-15T18:55:50+0000","data":{"title":{"text":"Как устроен словарь (dict) в Python"},"description":"Если с объяснением того, что такое дикт и как его юзать у нас проблем не возникает, то вот ответить как они устроены в Python, а при правильном ответе получить следующий: “А как решаются коллизии?”, то уже ответить проблематичнее.\nОтвечаю сразу на первый вопрос - в Python’e ассоциативный массив реализован с помощью хеш-таблицы (для заметки, в C++ красно-чёрные деревья). В основе всего лежит...","date":"29.02.2020","categories":[{"category":{"document":[{"id":"Prismic__Category__Xm4I9BEAACMABh0C","uid":"pro-python","data":{"name":"Про Python"}}]}}],"body":[{"__typename":"PrismicPostBodyText","slice_type":"text","id":"Prismic__PostBodyText__Prismic__Post__Xm56HxEAACAACBR0__body__0","primary":{"text":{"html":"<p>Если с объяснением того, что такое дикт и как его юзать у нас проблем не возникает, то вот ответить как они устроены в <em>Python</em>, а при правильном ответе получить следующий: “А как решаются коллизии?”, то уже ответить проблематичнее. </p><p>Отвечаю сразу на первый вопрос - в <em>Python’e</em> ассоциативный массив реализован с помощью хеш-таблицы (для заметки, в <em>C++</em> красно-чёрные деревья).</p><p>В основе всего лежит хеш-функция. И вот многие говорят, что хорошая хеш-функция эта то, что дает более рандомный ответ, но разрабы путона так не считают и их хеша схожи, даже для разных строк. Этим свойством они пользуются для оптимизации, но об этом ниже. </p><p>Уж не будем про то, что такое хеш, просто строка байт, полученная от какого-то алгоса, которому скормили какие-то входные данные. Для одинаковых данных будет один и тот же хеш. </p><p>В общем есть пару статей на эту тему, но там всё устарело, ибо с <em>Python3.6</em> были некоторые оптимайзы по памяти. То, как представлен словарь. Подходы, алги и т.д. не меняли. На данный момент <strong>PyDictObject</strong> представляет из себя структуру из:</p><ul><li>PyObject_HEAD:</li><li>ma_used;</li><li>ma_version_tag;</li><li>*ma_keys;</li><li>**ma_values.</li></ul><p><em><strong>ma_used</strong></em> - кол-во айтемов в словаре, <strong>ma_version_tag</strong> - просто глобальное уникальное значение, которое меняется при каждом изменении словаря.</p><p>Дальше объяснить будет чуть сложнее, ибо сейчас вкину то, о чем расскажу ниже.</p><p><em><strong>ma_keys</strong></em> - <em>PyDictKeysObject</em> который там в конце концов сводится к <em><strong>PyDictKeyEntry</strong></em> (пропущен жирный пласт с количеством юзабельных и использованных <em>entries</em> и т.д., сорри), а он, в свою очередь, состоит из:</p><ul><li>me_hash;</li><li>*me_key;</li><li>*me_value.</li></ul><p>С этой структурой всё понято, дык вот фича в том, что <em><strong>ma_keys</strong></em> конкретно для ключей и значений используется только тогда, когда таблица не является разорванной/разделенной (<em>splitted</em> короче). Когда же таблица “combined”, то ключи используются из <em>me_keys</em>, а значения из <em><strong>me_value</strong></em>!</p><p>Задетектить сплитед она или комбаин легко. Если<em> </em><code class=\"language-python\">me_value <span class=\"token keyword\">is</span> Null</code><em> </em>- <em>combined</em></p><p>Имеем хоть какое-то представление теперь о словарях в реализации <em>CPython</em>, идем дальше к самому вкусному.</p><p>В каждом слоте хеш-таблицы может храниться только один объект (хеш, ключ, значение).</p><p>Конечно же имеются коллизии (когда у двух разных объектов одинаковый хеш) и это нормально, такое надо уметь решать.</p><p>Есть несколько алгоритмов разрешать их, но в нашем случае - это открытая адресация. Есть ещё алгоритм через цеопчки (храним лист), но он проигрывает по памяти из-за хранение указателей на элементы в списке, но у него конечно есть плюсы. Речь не о чем, “Python” сделал свой выбор.  </p><p>Алгоритм открытой адресации очень прост. Мы берем хеш нашего ключа и делаем <em>MOD</em> <em>&lt;размер хеш-таблицы&gt;</em>. Таким образом получаем индекс для вставки нашего элемента. Что же происходит, когда ячейка уже занята? Просто берем и смотрим в следующую, да-да, тупо выходит следующее:</p><p><code class=\"language-cpp\"><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> TABLE_SIZE <span class=\"token operator\">+</span> i</code>, где<em> i</em>, какой-нибудь счетчик, пока не дойдем до свободной ячейки!</p><p>Когда нам необходимо найти что-то, то делаем тоже самое, только попав на какую-то ячейку проверяем её по хешу и ключу, если мы попали не туда - делаем +1 и смотрим дальше.</p><p>Хотим удалить что-то? Затираем элемент, но ставим маркер на эту ячейку, если за ней есть другие элементы, если нет - просто удаляем.</p><p>И вот как раз когда мы удаляем(затираем), появляются несколько последовательность, между которыми может стоять маркер. <strong>Это и есть splitted хэш-таблица!</strong></p><p>Маркер нужен для того, чтобы не прекратить наш линейный поиск ячейки с нужным нам значением тогда, когда мы дойдем до пустой ячейки (ибо дальше есть другие).</p><p>Понятное дело, что чем больше вот таких пустых мест, тем дольше мы будем всё искать и искать, куда же мы там сохранили. Для этого есть пересоздание словаря. Чет тип фрагментации что ль. Есть критическое значение маркеров, при котором создается новый словарь из старых значением, но без “пробелов” между ячейками.</p><p><em>Entry</em> в словаре (слот) может быть в одном из 4 состояний: <em>unused</em>, <em>active</em>, <em>dummy</em> и <em>pending</em>. Подробнее о каждом сможете почитать сами, снизу линк.</p><p><strong>НА САМОМ ДЕЛЕ НЕ ВСË ТАК ПРОСТО</strong></p><p>Я рассказал про банальную открытую адресацию, но в<em> Python’e</em> используют как раз то, что я упомянул выше - схожесть хешей. В связи с этим поиск нужной ячейки получается совсем не просто +1, а есть определенный шаг, с которым мы ходим. Есть <em>linear probing </em>(наш +1 каждый раз), а есть <em>double probing</em>. Фича второго в том, что мы двигаемся не на +1, а на хэш, но уже второй функции от того же <em>k</em>.</p><p>Я бы не сказал, что в<em> Python’e</em> используется двойное хеширование, у них своё. Шаг вычисляется так:</p><p><code class=\"language-cpp\">j <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">*</span> j<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> perturb<span class=\"token punctuation\">;</span></code></p><p>Всё это дико интересно конечно, но в то, как это работает я особо не вникал, хотя они всё подробно расписали в доке к методу (линк снизу).</p><p>Кста, есть фактик. Каждый словарь инициализируется с 8 слотами, что позволяет сохранять 5 элементов. Сделано это для того, что в большинстве мест, в самом <em>CPython</em> очень часто используются словари всего для 2-3 элементов и чтобы не использовать больше памяти, чем надо, поступили вот так. И да, насколько помню, у нас что в листах, что тут, всегда выделено больше памяти и больше доступно ячеек, чем есть на самом деле. То, что у вас <code class=\"language-python\"><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> </code>выдает 3, не значит, что там на самом деле столько ячеек. Связано это с тем, что выделять по 1 ячейке при каждом <em>append’e</em> слишком дорого по времени, поэтому выделяют всегда с запасом для следующих вставок. </p><p>Чтобы избежать замедления поиска в хеш-таблице она ресайзиться при заполнении на две трети.</p><p>Собсна у меня всё, было интересно посмотреть на исходники<em> CPython’a</em>. Будет что рассказать на собесах, надеюсь и Вам тоже. Я кста не перечитываю что написал, да-да. </p><p>Забылся. В коде вместо<em> %</em> (mod) стоит <em>&amp; (</em><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/python/cpython/blob/master/Objects/dictobject.c#L741\"><em>в</em>от про <em>MOD</em> из доки</a>):</p><p><code class=\"language-cpp\">size_t i <span class=\"token operator\">=</span> hash <span class=\"token operator\">&amp;</span> mask<span class=\"token punctuation\">;</span></code></p><p><code class=\"language-cpp\">i <span class=\"token operator\">=</span> mask <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">*</span><span class=\"token number\">5</span> <span class=\"token operator\">+</span> perturb <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></p><p>Фишка в том, что <em>mask</em> - размер таблицы минус 1, но размер таблицы всегда степень двойки.</p><p></p><p>Обещанные ссылки:</p><ul><li><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/python/cpython/blob/master/Objects/dictobject.c#L52\">от сюда про сплитед и компаинед таблицу, а так же про состояние ячеек</a></li><li><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/python/cpython/blob/master/Objects/dictobject.c#L135\">а вот от сюда жирная дока по тому, как же работает их <em>PERTURB_SHIFT</em> (эт который не тупое +1)</a></li><li><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/python/cpython/blob/master/Objects/dict-common.h\"><em>PyDictKeyEntry</em> и промежуточная структура, о которой я ничего не рассказал.</a></li><li><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/python/cpython/blob/master/Include/cpython/dictobject.h\">структура самого <em>PyDictObject</em></a></li><li><a target=\"_blank\" rel=\"noopener\" href=\"https://neerc.ifmo.ru/wiki/index.php?title=Разрешение_коллизий\">про разрешение коллизий</a></li><li><a target=\"_blank\" rel=\"noopener\" href=\"https://mail.python.org/pipermail/python-dev/2012-December/123028.html\">про изменение структуры с<em> Python3.6</em> для экономии памяти</a></li></ul>"}}}]}},"posts":{"nodes":[{"id":"Prismic__Post__Z3AWEBEAACQAq0KX","uid":"2024","data":{"title":{"text":"Итоги Года 2024"},"date":"28.12.2024","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__ZYgWYhAAACYAKMp2","uid":"2023","data":{"title":{"text":"Итоги Года 2023"},"date":"31.12.2023","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__Y62KDBAAACYAwfBO","uid":"2022","data":{"title":{"text":"Итоги Года 2022"},"date":"31.12.2022","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__Y639RhAAACMAwpTU","uid":"2021","data":{"title":{"text":"Итоги Года 2021"},"date":"31.12.2021","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}}]}},"pageContext":{"uid":"kak-ustroen-slovar-dict-v-python"}}}