{"componentChunkName":"component---src-templates-post-jsx","path":"/blog/post/gil-global-interpreter-lock-v-python","result":{"data":{"prismicPost":{"id":"Prismic__Post__Xm57aBEAACAACBo0","uid":"gil-global-interpreter-lock-v-python","first_publication_date":"2020-03-15T19:00:59+0000","last_publication_date":"2020-03-15T19:02:42+0000","data":{"title":{"text":"GIL (Global Interpreter Lock) в Python"},"description":"Изначально я хотел сразу начать отвечать на вопрос с собеса про память в Python, но поняв, что выйдет очень длинно, решил разбить на несколько постов.\nСейчас поговорим про GIL, в следующих статьях про GC, закончим уже поверхностно про пуллы памяти, арены.\nGIL - это просто лок, который разрешает только одному потоку удерживать контроль на интерпретатором Python'a (собсна такое определение можно","date":"05.03.2020","categories":[{"category":{"document":[{"id":"Prismic__Category__Xm4I9BEAACMABh0C","uid":"pro-python","data":{"name":"Про Python"}}]}}],"body":[{"__typename":"PrismicPostBodyText","slice_type":"text","id":"Prismic__PostBodyText__Prismic__Post__Xm57aBEAACAACBo0__body__0","primary":{"text":{"html":"<p>Изначально я хотел сразу начать отвечать на вопрос с собеса про память в <em>Python</em>, но поняв, что выйдет очень длинно, решил разбить на несколько постов.</p><p>Сейчас поговорим про <em>GIL</em>, в следующих статьях про <em>GC</em>, закончим уже поверхностно про пуллы памяти, арены.</p><p><em>GIL</em> - это просто лок, который разрешает <strong>только одному </strong>потоку удерживать контроль на интерпретатором <em>Python&#39;a </em>(собсна такое определение можно было дать и из названия).</p><p>Не просто так конечно выделил жирным про один поток. Да, в этом вся печаль и рофел. Никакого параллельного выполнения потоков у нас НЕТ! Когда речь идет о однопоточной программе, то вообще всё равно, но если мы работаем в нескольких потоках, то это бьёт нам по производительности. Всё это можно сравнить с ядрами нашего ЦП. Мы всегда исключительно используем одно, а другие просто наблюдают как другой напрягается.</p><p><em>GIL</em> нужен для решения проблемы <em>race conditions</em>. Сразу на примере, но придется затронуть чутка сборщик мусора. У каждого объекта (<em>PyObject</em>) есть <em>Py_REFCNT</em> где хранится количество ссылок на этот объект. Когда количество ссылок становится равным нулю - происходит освобождение памяти. Если количество ссылок <code class=\"language-python\"><span class=\"token operator\">==</span> <span class=\"token number\">0</span></code>, то, понятное дело, объект нигде не используется и достучаться до него из кода уже невозможно. Возвращаемся к проблеме. Когда у нас многопоточное приложение, то один поток может удалить ссылку и сделать <code class=\"language-python\"><span class=\"token operator\">-=</span> <span class=\"token number\">1</span></code> к данной переменной, а другое наоборот захочет сделать <code class=\"language-python\"><span class=\"token operator\">+=</span> <span class=\"token number\">1</span></code>. Желание у них появилось одновременно и непонятно какое значение у переменной будет в конце. В итоге это приведет к непоняткам. Или объект случайно удалится <em>GC</em>, хотя на него есть ссылка где-то, или наоборот, никогда не удалится. Будет дичь.</p><p>Решением это дичи будет добавление локов к каждому объекту, что использует эту переменную с количеством ссылок. Дабы организовать последовательное обращение к переменной. Стоит лок - ждем. Свободно - заходим и лочимся за собой. Когда уходим - разлокиваем. Звучит просто, но лок в каждом объекте приводит во-первых к их огромному количеству, а во-вторых к <em>дедлокам</em>. <em>Дедлок -</em> это такая ситуация, что мы сидим, ждем пока там освободят эту переменку, но она не освобождается. Почему? Потому что кто её ждет сам её и удерживает.</p><p>Поэтому <em>GIL -&gt; Global -&gt; single</em> и так мы пришли да, к одному общему, глобальному локу для всех.</p><p>Данный лок элементарно и круто справляется со своей задачей. У нас никого не возникает проблем. Никаких гонок, никаких дедлоков, ляпота же. Только вот мы теряем производительность. Сам этот <em>GIL</em> был написан чертовски давно. То, что используется сейчас, было написано ещё 10 лет назад (в 2009) и особых изменений с того времени не было.</p><p><em>GIL</em> был выбран ещё на этапах проектирования <em>Python&#39;a</em>. Как обычно в моих статьях, не могу не сказать про то, что <em>Python</em> является простым и для всех, для любых задач. Собсна тогда (да и сейчас) многие расширения на <em>C</em> требовали безопасного менеджмента памяти, а <em>GIL</em> это давал с помощью очень простого решения. В общем, так исторически сложилось и сейчас он так сильно врос, что от него сложно избавиться, но процесс уже запущен (сабинтепретаторы в <em>Python 3.8</em>). Нельзя просто так взять и выбросить <em>GIL</em> (можно, это уже делали), ибо это сломает огромное количество всё тех же расширений <em>C</em>.</p><p>Мы получаем в <em>CPython</em> какой-то флаг (или семафор) и каждый поток должен запрашивать у нашего <em>GIL&#39;a</em> доступ. Сама блокировка находится в основном цикле нашего байткода, о байткоде я писал в одной из прошлой статье. В текущей реализации нет приоритетов, нет четкой последовательности какой поток получит следующим доступ. Ничего этого нет. Всё это перекладывается на ОС.</p><p>Вверху всё было про то, что уже есть. Однако в последних версиях <em>Python&#39;a</em>, как я уже упомянул чуть выше, есть <em>subinterpreters. </em>Суть проста: у нас есть процесс, у него есть несколько интерпретаторов (о то что это тоже в прошлой статье), у каждого интерпретатора конечно же свой <em>GIL</em>, а уже у интерпретаторов свой набор потоков. Конечно нам нужен доступ какой-то общий между двумя интерпретаторами, но у нас ведь два <em>GIL&#39;a</em>. Поэтому предлагается добавить общую память между ними и использовать указатели для поиска объектов. В данном случае управлять блокировками между интерпретаторами будет сам процесс. Но как я понял, какого-то <em>API</em> для такого шардирования ещё нет.</p><p><a target=\"_blank\" rel=\"noopener\" href=\"https://www.python.org/dev/peps/pep-0554\">PEP 554 как раз про сабинтерпретаторы, шардирование и бла-бла</a> (там вон даже файловые дескрипторы шарят)</p><p>Ниже классный старый видосик для куда более тонкого понимания <em>GIL&#39;a,</em> но мне хватит и текущих знаний (пока что), а Вам?</p><p><a  href=\"https://www.youtube.com/watch?v=Obt-vMVdM8s\">https://www.youtube.com/watch?v=Obt-vMVdM8s</a></p>"}}}]}},"posts":{"nodes":[{"id":"Prismic__Post__Y639RhAAACMAwpTU","uid":"2021","data":{"title":{"text":"2021"},"date":"31.12.2021","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__Y64jWxAAACQAwssK","uid":"2020","data":{"title":{"text":"2020"},"date":"31.12.2020","categories":[{"category":{"document":[{"id":"Prismic__Category__Y635ZxAAACQAwo9V","uid":"results-of-the-year","data":{"name":"Итоги Года"}}]}}]}},{"id":"Prismic__Post__X4H6aBIAACIAIjDy","uid":"generaciya-shemy-sborki-kartiny-fotografii-iz-lego","data":{"title":{"text":"Генерация схемы сборки картины-фотографии из LEGO"},"date":"10.10.2020","categories":[{"category":{"document":[{"id":"Prismic__Category__Xm56eREAACMACBYT","uid":"poznavatelno","data":{"name":"Познавательно"}}]}}]}},{"id":"Prismic__Post__X4G7ihIAACQAISVC","uid":"vash-pereezd-yandeksmuzyka-spotify","data":{"title":{"text":"Ваш переезд: Яндекс.Музыка -> Spotify"},"date":"16.07.2020","categories":[{"category":{"document":[{"id":"Prismic__Category__XnKTYxIAACcADKwY","uid":"raznoe","data":{"name":"Разное"}}]}}]}}]}},"pageContext":{"uid":"gil-global-interpreter-lock-v-python"}}}